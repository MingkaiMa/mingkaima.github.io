<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Mingkai&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Mingkai&#39;s personal blog">
<meta property="og:type" content="website">
<meta property="og:title" content="Mingkai&#39;s Blog">
<meta property="og:url" content="https://mingkaima.github.io/index.html">
<meta property="og:site_name" content="Mingkai&#39;s Blog">
<meta property="og:description" content="Mingkai&#39;s personal blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Mingkai Ma">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Mingkai's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Mingkai&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://mingkaima.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-Scheduling" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/07/Scheduling/" class="article-date">
  <time class="dt-published" datetime="2021-07-07T03:42:48.000Z" itemprop="datePublished">2021-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/07/Scheduling/">Scheduling</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="Scheduling"><a href="#Scheduling" class="headerlink" title="Scheduling"></a>Scheduling</h1><p>When a computer is multiprogrammed, it has multiple process or threads competing for the CPU at the same time,  and if only <strong>one CPU</strong> is available, a choice has to be made which process to run next.</p>
<p>The <strong>scheduler</strong> is the part of the OS that makes the choice, using scheduling algorithm.</p>
<ol>
<li><p>Process Behaviour</p>
<ul>
<li>Compute-bound</li>
<li>I/O-bound</li>
</ul>
</li>
<li><p>When to Schedule</p>
<ul>
<li>When a new process is created, a decision needs to be makde whether to run the parent process or the child process.</li>
<li>When a process exits.</li>
<li>When a process blocks on I/O, on a semaphore, or for some other reason, another process has to be selected to run.</li>
<li>When an I/O interrupt occurs.</li>
<li>Scheduling algorithms<ul>
<li>two categories with respect to how they deal with clock interrupts<ul>
<li>Nonpreemptive scheduling algorithm</li>
<li>Preemptive scheduling algorithm</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Catogories of Scheduling Algorithms</p>
<p>In different situations, different scheduling algorithms are needed.</p>
<ul>
<li>Batch</li>
<li>Interactive</li>
<li>Real time</li>
</ul>
</li>
<li><p>Scheduling Algorithms Goals</p>
<ul>
<li>All Systems<ul>
<li>Fairness - giving each process a fair share of the CPU</li>
<li>Policy enforcement - seeing that stated policy is carried out</li>
<li>Balance - keeping all parts of the system busy</li>
</ul>
</li>
<li>Batch Systems<ul>
<li>Throughput - maximize jobs per hour</li>
<li>Turnaround time - minimize time between submission and termination</li>
<li>CPU utilization - keep the CPU busy all the time.</li>
</ul>
</li>
<li>Interactive systems<ul>
<li>Response time - respond to requests quickly</li>
<li>Proportionality - meet users’ expections</li>
</ul>
</li>
<li>Real-time Systems<ul>
<li>Meeting deadlines - avoid losing data</li>
<li>Predictability - avoid quality degradation in multimedia systems</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="Scheduling-in-Batch-Systems"><a href="#Scheduling-in-Batch-Systems" class="headerlink" title="Scheduling in Batch Systems"></a>Scheduling in Batch Systems</h4><h5 id="First-Come-First-Served"><a href="#First-Come-First-Served" class="headerlink" title="First-Come First-Served"></a>First-Come First-Served</h5><ul>
<li>nonpreemptive</li>
<li>easy to understand and equally easy to program</li>
<li>can be implemented via linked-list</li>
<li>Disadvantage: Throughput can be low …</li>
</ul>
<h5 id="Shortest-Job-First"><a href="#Shortest-Job-First" class="headerlink" title="Shortest Job First"></a>Shortest Job First</h5><ul>
<li>nonpreemptive algorithm that assumes the run times are know in advance</li>
<li>Consider the case of tour jobs, with run times of a, b, c, and d, respectively. The mean turnaround time is (4a + 3b + 2c + d) / A<ul>
<li><em>a</em> contributes more to the average than the other times, so it should be the shortest job</li>
</ul>
</li>
<li>only optimal when all the jobs are available simultaneously</li>
</ul>
<h5 id="Shortest-Remaing-Time-Next"><a href="#Shortest-Remaing-Time-Next" class="headerlink" title="Shortest Remaing Time Next"></a>Shortest Remaing Time Next</h5><ul>
<li>preemptive version of shortest job first</li>
<li>the scheduler always chooses the process whose remaining run time is the shortest</li>
<li>this scheme allows nwe short jobs to get good service</li>
</ul>
<h4 id="Scheduling-in-Interactive-Systems"><a href="#Scheduling-in-Interactive-Systems" class="headerlink" title="Scheduling in Interactive Systems"></a>Scheduling in Interactive Systems</h4><h5 id="Round-Robin-Scheduling"><a href="#Round-Robin-Scheduling" class="headerlink" title="Round-Robin Scheduling"></a>Round-Robin Scheduling</h5><p>Each process is assigned a time interval, called its quantum, during which it is allowed to run. If the process is still running at the end of the quantum, the CPU is preempted and given to another process. If the process has blocked or finished before the quantum has elapsed, the CPU switching is done when the process blocks, of course.</p>
<ul>
<li>the scheduler maintains a lsit of runnable process. When the process uses up its quantum, it is put on the end of the list.</li>
</ul>
<h6 id="The-length-of-die-quantum"><a href="#The-length-of-die-quantum" class="headerlink" title="The length of die quantum"></a>The length of die quantum</h6><p>Switching from one process to another requires time, so process swithcing or context switch takes time.</p>
<p>To improve the CPU efficiency, we should set the quantum to a large number, compared with switching time. </p>
<p>Disadvantage: this situation is bad if some of the requests near the end of the queue requires only a few milliseconds of CPU time.</p>
<p>Conclusion:</p>
<p>setting the quantum too short causes too many process switches and lowers the CPU efficiency, but setting it too long may cause poor response to short interactive requests. A quantum around 20-50 msec is often a reasonable compromise.</p>
<h5 id="Priority-Scheduling"><a href="#Priority-Scheduling" class="headerlink" title="Priority Scheduling"></a>Priority Scheduling</h5><p>Each process is assigned a priority, and the runnable process with the highest priority is allowed to run.</p>
<p>To prevent high-priority processes from runing indefinitely:</p>
<ul>
<li>Decrease the priority of the currently running process at each clock tick.</li>
<li>Each process may be assigned a maximum time quantum that it’s allowed to run.</li>
</ul>
<p>Group processes into priority classes and use priority scheduling among the classes but round-robin scheduling with each class.</p>
<ul>
<li>If priorities are not adjusted occasionally, lower priority classes may all starve to death.</li>
</ul>
<h5 id="Multiple-Queues"><a href="#Multiple-Queues" class="headerlink" title="Multiple Queues"></a>Multiple Queues</h5><p>It was more efficient to give CPU-bound processes a large quantum once in a while, rather than giving them small quantum frequently(to reduce swapping).</p>
<p>However, giving all processes a large quantum would mean poor response time.</p>
<p>⬇</p>
<p>The solution was to set up priority classes.</p>
<hr>
<p>Example:</p>
<p>A process that needs to compute continuously for 100 quanta.</p>
<p>Algorithm:</p>
<blockquote>
<p>Initially be given one quantum, then swapped out.</p>
<p>Next time it woud get two quanta before being swapped out.</p>
<p>Then it would get 4, 8, 16, 32 and 64 quanta.</p>
<p>It would have used only 37 of the final 64 quanta to complete.</p>
<p>Only 7 swaps instead of 100 with a pure round-robin algorithm</p>
</blockquote>
<hr>
<h5 id="Shorest-Process-Next"><a href="#Shorest-Process-Next" class="headerlink" title="Shorest Process Next"></a>Shorest Process Next</h5><blockquote>
<p>The only problem is figuring out which of the currently runnable processes is the shortest one.</p>
<blockquote>
<p>Making estimates based on past behaviour and run the process with the shortest estimated running time.</p>
<blockquote>
<p>Suppose that the estimated time per command for some terminal is T<sub>0</sub> , and suppose its next run is measured  T<sub>1</sub> , we could update our estimate by taking a weighted sum of these two numbers:</p>
<p>a T<sub>0</sub> + (1 - a) T<sub>1</sub></p>
<p>Through the choice of <em>a</em> we can decide to have the estimation process forget old runs quickly, or remember them for a long time.</p>
<p>With <em>a</em> = 1/2, we get the successive estimates of:</p>
<p>T<sub>0</sub> </p>
<p>T<sub>0</sub> / 2 + T<sub>1</sub> / 2</p>
<p>T<sub>0</sub> / 4 + T<sub>1</sub> / 4 + T<sub>2</sub> / 2</p>
<p>T<sub>0</sub> / 8 + T<sub>1</sub> / 8 + T<sub>2</sub> / 4 + T<sub>3</sub> / 2</p>
</blockquote>
<p>Aging:</p>
<blockquote>
<p>The technique of estimating the next value in a series by taking the weighted average of the current measured value and the previous estimated.</p>
</blockquote>
</blockquote>
</blockquote>
<h5 id="Guaranteed-Scheduling"><a href="#Guaranteed-Scheduling" class="headerlink" title="Guaranteed Scheduling"></a>Guaranteed Scheduling</h5><p>Making real promises to the users about performance.</p>
<blockquote>
<p>If there are n users logged in, one use will receive aobut 1/n of the CPU power.</p>
</blockquote>
<h5 id="Lottery-Scheduling"><a href="#Lottery-Scheduling" class="headerlink" title="Lottery Scheduling"></a>Lottery Scheduling</h5><blockquote>
<p>Basic idea:</p>
<p>To give processes lottery tickets for various system resources, such as CPU time. Whenever a scheduling decision has to be made, a lottery ticket is chosen at random, and the process holding that ticket gets the resource.</p>
<p>Exmaple:</p>
<p>Suppose: the system holds a lottery 50 times a second</p>
<p>Then: each winner getting 20 msec of CPU time as a price</p>
<blockquote>
<p>1 / 50 = 0.02s = 20 msec</p>
</blockquote>
<p>To paraphrase <strong>George Orwell</strong>:</p>
<blockquote>
<p>All processes are equal, but some processes are more equal than other.</p>
<blockquote>
<p>Original quote: All animals are equal, but some animals are more equal than others</p>
</blockquote>
</blockquote>
<p>More important processes can be given extra tickets to increase their odds of winning.</p>
<blockquote>
<p>Example:</p>
<p>100 tickets outstanding, and one process holds 20 of them.</p>
<p>Then it will have a 20% chance of wining each lottery, in the long run, it will get about 20% of the CPU.</p>
</blockquote>
<p>The rule is clear:</p>
<blockquote>
<p>a process holding a fraction <em>f</em> of the ciekts will get about a fraction <em>f</em> of the resource.</p>
</blockquote>
<p>Interegsting properties:</p>
<ol>
<li><p>lottery scheduling is highly responsive</p>
</li>
<li><p>Cooperating processes may exchange tickets if they wish</p>
</li>
<li><p>Solve problems that are difficult to handle with other methods</p>
<blockquote>
<p>Video server exmaple</p>
</blockquote>
</li>
</ol>
</blockquote>
<h5 id="Fair-Share-Scheduling"><a href="#Fair-Share-Scheduling" class="headerlink" title="Fair-Share Scheduling"></a>Fair-Share Scheduling</h5><blockquote>
<p>Some systems take into accout who owns a process before scheduling it.</p>
</blockquote>
<blockquote>
<p>In this model, each user is allocated some fraction fo the CPU and the scheduler picks processes in such a way as to enforce it.</p>
</blockquote>
<h4 id="Scheduling-in-Real-Time-Systems"><a href="#Scheduling-in-Real-Time-Systems" class="headerlink" title="Scheduling in Real-Time Systems"></a>Scheduling in Real-Time Systems</h4><blockquote>
<p><strong>Real-time system</strong>:</p>
<p>in which time plays an essential role. Typically, one or more physical devices external to the computer generate stimuli, and the comuter must react appropriately to them with a fixed amount of time.</p>
<p>Example:</p>
<ol>
<li>the computer in a compact dics player</li>
<li>patient monitoring in a hospital ICU.</li>
<li>the autopilot in an aircraft</li>
<li>robot control in an automated factory.</li>
</ol>
<p><strong>Having the right answer but having it too late is often just as bad as not having it at all</strong>.</p>
<p>Categories two types:</p>
<ol>
<li>hard real time<ul>
<li>Having absolute deadlines must be met</li>
</ul>
</li>
<li>soft real time<ul>
<li>missing an occasional deadline is undesirable, but nevertheless tolerable.</li>
</ul>
</li>
</ol>
<p>In both cases, real-time behaviour is achieved by dividing the program into a number of processes, each of whose behaviour is predictable and known in advance.</p>
<blockquote>
<p>these processes are short lived and can run to completion in well under a second.</p>
</blockquote>
<p><strong>Events</strong></p>
<p>Periodic  | Aperiodic</p>
<p>A system may have to respond to multiple periodic event streams, depending on how much time each event requires for proceessing, it may not even be possible to handle them all.</p>
<p>Example:</p>
<p>suppose there are <em>m</em> periodic events and event <em>i</em> occurs with period P<sub>i</sub> and requires C<sub>i</sub> seconds of CPU time to handle each event, then the <strong>load</strong> can be handled if:<br>$$<br>\sum_{i=1}^{m} \frac{C_{i}}{P_{i}} \le 1<br>$$<br>A real-time system that meets this criterion is said to be <strong>schedulable</strong>.</p>
<p><strong>Scheduling algorithms</strong></p>
<p>Static | Dynamic</p>
</blockquote>
<h4 id="Policy-versus-Mechanism"><a href="#Policy-versus-Mechanism" class="headerlink" title="Policy versus Mechanism"></a>Policy versus Mechanism</h4><blockquote>
<p>None of the schedulers discussed above accept any input from user processes about scheduling decisions.</p>
<p>The solution to this problem is to separate the scheduling mechanism from the scheduling policy.</p>
<p>What is means is that the scheduling algorithm is parameterized in some way, and the parameters can be provided by user processes.</p>
</blockquote>
<h4 id="Thread-Scheduling"><a href="#Thread-Scheduling" class="headerlink" title="Thread Scheduling"></a>Thread Scheduling</h4><p>When several processes each have multiple threads, we have two levels of parallelism present: processes and threads.</p>
<p>Scheduling in such systems differs greatly depending on whether user-level threads or kernel-level threads (or both) are supported.</p>
<p><strong>User-level threads</strong></p>
<blockquote>
<p>The kernel is not aware of the existence of threads, it picks a process (A) and gives A control of its quantum. The thread scheduler inside A decides which thread to run, say A<sub>1</sub>, since there are no clock interrupts to multiprogram threads, this thread may continue running as long as it wants to. If it uses up the process’ entire quantum, the kernel will select another process to run.</p>
</blockquote>
<blockquote>
<p>Consider the case that A’s threads ahve relatively little work to do per CPU burst.</p>
<p>The scheduling algorithm used by the run-time system can be any of the ones described above. Round-robin and priority scheduling are most common in practice.</p>
<p>The only constraint is the absence of a clock to interrupt a thread that has run too long.</p>
</blockquote>
<p><strong>Kernel-level threads</strong></p>
<blockquote>
<p>Here the kernel picks a particular thread to run.</p>
</blockquote>
<p><strong>Difference between two level threads</strong></p>
<blockquote>
<p>A major difference is performance.</p>
<ul>
<li><p>Doing a thread switch with user-level threads takes a handful of machine instructions</p>
<p>Doing a thread switch with kernel-level requires a full context switch, changing the memory map and invalidating the cache, which is several orders of magnitude slower</p>
</li>
<li><p>With kernel-level threads, having a thread block on I/O, does not suspend the entire process as it does with user-level threads</p>
</li>
<li><p>User-level threads can employ an application-specific thread scheduler.</p>
</li>
</ul>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mingkaima.github.io/2021/07/07/Scheduling/" data-id="ckqsxxz5p0000sz98cnw6hvp9" data-title="Scheduling" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/07/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-07-07T03:40:08.292Z" itemprop="datePublished">2021-07-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/07/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://mingkaima.github.io/2021/07/07/hello-world/" data-id="ckqsxop4x0000r1984zj6c8oa" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/07/07/Scheduling/">Scheduling</a>
          </li>
        
          <li>
            <a href="/2021/07/07/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Mingkai Ma<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>